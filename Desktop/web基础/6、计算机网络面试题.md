#### 1、描述一下TCP三次握手和四次挥手

- 三次握手
  - 第一次握手：客户端向服务端发送SYN，是否可以连接
  - 第二次握手：服务端向客户端发送SYN，响应客户端可以进行连接
  - 第三次握手：客户端向服务端发送ACK，向服务端发送请求
- 四次挥手
  - 第一次挥手：客户端告诉服务端，客户端的请求已经结束了
  - 第二次： 服务端接收到请求，告诉客户端收到了，但是这时候客户端之前请求的数据还在发送
  - 第三次：服务端告诉客户端，数据全部发送完毕，等待客户端发送断开请求
  - 第四次：客户端告诉服务端可以关闭连接了，服务端收到，关闭连接

- 为什么要进行三次握手
  - 三次握手最主要的目的就是**双方确认自己与对方的发送与接收是正常的**。

- 为什么要四次挥手
  - 由于 TCP 的**半关闭**（half-close）特性，TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。
  - **两次握手就可以释放一端到另一端的 TCP 连接，完全释放连接一共需要四次握手**

#### 2、http跨域为什么要发送options请求

- options请求是跨域请求之前的预检查
- 浏览器自行发起的
- 不会影响实际开发

#### 3、http跨域

- 同源策略：同源策略是浏览器的一个行为
- 当你发送请求的时候会涉及两个地址
  - 打开页面的地址
  - 你要请求的地址
- 两个地址中的传输协议，域名，端口号有一个不一样，就是非同源请求，就会触发同源策略，不允许你获取这个服务器的数据
- 触发了同源策略的请求叫做跨域请求
- 实现跨域请求的方式
  - jsonp
  - cors
  - 代理Proxy

#### 4、jsonp

- jsonp的原理：

  - 利用了src不受浏览器的同源策略的影响
  - script会把请求的内容当做js代码来执行

- jsonp的返回值

  - ​	一个字符串 函数名（）形式的字符串

- jsonp的优缺点：

  - 优点：可以实现跨域请求，方便
  - 缺点：不好做安全防护

- jsonp的核心：

  - 利用一个script标签的src属性
  - 去向一个非同源的服务器请求数据

  - 只要这个服务器能给我返回一个字符串
  - 我就会把这个字符串当做js代码来执行

#### 5、Proxy代理跨域

- 正向代理：相当于我们把请求发送到同源的代理服务器上，让代理服务器去真正的服务器发送请求，服务器也是把请求结果返回给代理服务器，代理最后交给客户端，这样便绕开了同源策略。服务器并不知道是哪个客户端发送的请求
- 反向代理： 在服务器同源的位置设置一个服务器，客户端的所有请求，都会去这个服务器请求，然后由代理服务器，向真正的数据服务器发送请求，特点是，客户端并不知道，真正的服务器地址，也不知道哪个服务器传过来的数据。

#### 6、cors-跨域资源共享

- 因为跨域请求，不是请求发不出来
- 而是因为，我们给服务器发送请求，服务返回给我们数据的时候
- 因为浏览器判断是非同源，所有不允许我们使用浏览器的数据
- 这时候就通过服务器端告诉浏览器，这个域名允许请求我的内容，给服务器端添加响应头

#### 7、cookie

- 浏览器端的本地存储空间
- 用来存储数据
- 特点：
  - 按照域名存储：哪个域名存储的，在当前域名下就可以访问
  - 换个域名就不能访问
  - 存储大小在4kb左右
  - 前后端都可以进行操作
  - 请求数据的时候会自动携带cookie
  - 时效性： 默认关闭浏览器就没了，可以自己设置

#### 8、session

- 当浏览器向服务器发送请求的时，服务器首先会检查这个客户端请求是否携带了sessionid，
- 如果有，则说明这个客户端创建过session，服务端根据这个sessionID把这个session检索出来使用
- 如果没有，服务端会为客户端创建一个sessionID放入cookie中，这样客户端在发送请求的时候都会带着sessionID，以此来达到共享数据
- session不会随浏览器 的关闭而关闭，而是等待超时时间

#### 9、cookie和session区别

- cookie存储在客户端，session存储在服务器端
- cookie的安全性没有session的好
- 存储大小不同，session没有固定的存储大小
- cookie可以长时间保存而session不行

#### 10、请求方式

- ```
  <!--
    ``请求方式
     ``+ 前端和后端的交互手段
     ``+ 最早: 不分 GET POST
      ``=> 后来为了语义化, 做了一些区分
      ``=> 本质是一样的
  ```

  ```
    ``常见的请求方式
     ``HTTP/1.0
      ``1. GET : 偏向于获取的方式
       ``+ 大部分都是给后端一些参数, 用来获取一些列数据
      ``2. POST : 偏向于给服务器一些数据
       ``+ 大部分都是登录, 给服务器一些信息, 你给我一个简单的结果
      ``3. PUT : 偏向于给服务器一些信息, 但是是添加使用
       ``+ 大部分做注册, 给服务器一些信息, 你把这个信息存起来
      ``4. HEAD : 用来获取服务器头信息
     ``HTTP/1.1
      ``5. DELETE : 偏向于删除
       ``+ 大部分是删除评论, 删除微博
      ``6. CONNECT: 管道连接改变代理连接使用
      ``7. PATCH : 偏向于给服务器一些信息, 偏向于修改一些信息
       ``+ 大部分用于完善用户资料
      ``8. OPTIONS: 用于获取服务器性能, 但是需要服务端同意
     ``二阶段: 只用 GET 和 POST
  ```

  

#### 11、http和https的区别

- HTTP是超文本传输协议，信息是明文传输；HTTPS则是具有安全性的ssl加密传输协议。
- HTTP和HTTPS用的端口不一样，HTTP端口是80，HTTPS是443。
- HTTPS协议需要到CA机构申请证书，一般需要一定的费用。
- HTTP运行在TCP协议之上；HTTPS运行在SSL协议之上，SSL运行在TCP协议之上。

#### 12、http协议的特点

- HTTP允许传输任意类型的数据。传输的类型由Content-Type加以标记。
- 无状态。对于客户端每次发送的请求，服务器都认为是一个新的请求，上一次会话和下一次会话之间没有联系。
- 支持客户端/服务器模式。

#### 13、http状态码

- 1xx：服务器收到请求，需要请求者继续进行操作

- 2xx：请求正常处理完毕

- 3xx：重定向

- 4xx：客户端错误，服务器无法处理请求

- 5xx：服务器处理请求出错

- ```js
  常见状态码
     ``+ 101 表示连接继续
     ``+ 200 通用成功
     ``+ 302 临时重定向(百度搜索)
      ``=> 本次请求临时使用 服务器 来决定浏览器跳转的页面
     ``+ 301 永久重定向(京东360buy.com)
      ``=> 终身只要访问这个地址, 就会给重新切换到新的地址
     ``+ 304 缓存
      ``=> 当你访问过一遍这个页面以后
      ``=> 浏览器会自动缓存
      ``=> 当你在其访问同一个地址的时候, 不会像服务器发送请求了, 而是从缓存里面获取
     ``+ 403 访问权限不够
     ``+ 404 访问地址不存在
     ``+ 500 通用服务端错误
     ``+ 501 维护或者过载
  ```

#### 14、http传输协议

- ```js
  <!--
    ``http 传输协议
     ``+ 前后端交互的方式
     ``+ 前端以什么样的形式发送数据给后端
     ``+ 后端以什么样的形式返回数据给前端
  ```

  ```js
    ``传输协议
     ``1. 必须经历四个步骤
      ``1-1. 建立连接
      ``1-2. 发送请求(前端给后端)
      ``1-3. 返回响应(后端给前端)
      ``1-4. 断开连接
     ``2. 只能由前端发起
      ``+ 不能由后端主动沟通前端
     ``3. 一次只能说一个事情
      ``+ 对于着一个事情你可以尽可能的描述的详细
      ``+ 但是一次连接只能沟通一个事情
     ``4. 前后端交互只能交互字符串
      ``+ 所有其他数据类型都不可以
      ``+ 中文会转成 url 编码
  ```

  ```js
    ``一个请求的四个步骤
  ```

  ```js
    ``1. 建立连接
     ``+ 基于 TCP / IP 协议的三次握手
     ``+ 浏览器和服务器做的
     ``+ 目的: 为了保证通道的连接
      ``1. 前端和后端说: "你在吗"
      ``2. 后端和前端说: "我再"
       ``-> 后端知道 前端正常发送
       ``-> 后端知道 后端正常接收
      ``3. 前端和后端说: "好的我知道了"
       ``-> 前端知道 后端正常接收
       ``-> 前端知道 前端正常发送
       ``-> 前端知道 前端正常接收
       ``-> 前端知道 后端正常发送
      ``4. 后端和前端说: "你发送请求吧"
       ``-> 后端知道 前端正常接收
       ``-> 后端知道 后端正常发送
  ```

  ```js
    ``2. 发送请求
     ``+ 前端发送请求给后端, 必须以 请求报文 的形式发送
     ``+ 一个特殊格式的字符串文件(由浏览器进行组装)
     ``+ 请求报文
      ``=> 请求行
       ``-> GET / POST: 请求方式(未完待续)
       ``-> ./login.php: 请求地址
       ``-> HTTP/1.1: 传输协议版本
      ``=> 请求头
       ``-> 对本次请求的描述信息
       ``-> Host: 请求主机
       ``-> Accapt: 期望的数据类型
       ``-> UserAgent: 请求终端
       ``-> Content-type: 请求体的数据格式
       ``-> ...
       ``-> Cookie: (未完待续)
      ``=> 请求空行
       ``-> 分隔请求体和请求头的
      ``=> 请求体
       ``-> 前端携带给后端的参数
       ``-> 有的有, 有的没有
  ```

  ```js
    ``3. 接收响应
     ``+ 每一个响应是由服务端接收到前端的请求以后, 给出的结果
     ``+ 必须以响应报文的形式发送个前端
     ``+ 响应报文
      ``1. 状态行
       ``=> 200: 响应状态码(未完待续)
       ``=> ok: 对响应状态码的简单描述
       ``=> HTTP/1.1 传输协议版本
      ``2. 响应头
       ``=> 对本次响应的描述信息
       ``=> Date: 服务器时间(世界标准时间)
       ``=> Server: 服务器信息
       ``=> Content-Type: 响应体的数据格式
       ``=> ...
      ``3. 响应体
       ``=> 后端给前端的数据
  ```

  ```js
    ``4. 断开连接
     ``+ 基于 TCP / IP 协议的四次挥手
     ``+ 为了保证断开连接
      ``1. 前端给后端发一个消息: "响应体收到, 我要准备断开连接了"
      ``2. 后端给前端发一个消息: "好的, 我知道你收到响应体了"
      ``3. 后端在其给前端发一个消息: "我已经准备断开连接了, 当我再次收到你的消息的时候, 我就断了, 不会再次回覆"
      ``4. 前端收到后端的第一个消息
      ``5. 前端收到后端的第二个消息: "好的, 我断开了, 别回了"
      --!>
  ```

#### 15、get和post请求的区别

- ```js
  ``GET 和 POST 请求方式的区别(重点!!!)
     ``+ GET
      ``1. 语义是获取
      ``2. GET 携带参数的方式是 queryString, 在地址栏后面直接拼接, 不再请求体里面
      ``3. GET 理论上携带数据无限, 但是因为浏览器地址栏有限, IE 2KB
      ``4. GET 会被浏览器主动缓存
      ``5. GET 明文发送
      ``6. GET 只能发送 url 编码的数据(ASCII 码), 如果是中文会自动转码
     ``+ POST
      ``1. 语义是给
      ``2. POST 携带载时是 requestBody, 在地址栏没有, 在请求体里面
      ``3. POST 理论上携带的数据无限, 但是会被服务器限制
      ``4. POST 请求不会被浏览器主动缓存, 除非手动设置
      ``5. POST 暗文发送
      ``6. POST 理论上可以发送任意格式的数据, 但是要和请求头里面得 content-type 配套
  ```

  

#### 16、强缓存和协商缓存

- 强缓存：浏览器直接从本地缓存中获取数据，不与服务器进行交互

- 协商缓存：浏览器发送请求到服务器，服务器判断是否可使用本地缓存

  